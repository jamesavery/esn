import joblib
import numpy as np
import scipy.stats as stats
from scipy import sparse
from functools import partial

import jax
import jax.numpy as jnp
from jax import lax

from esn.jaxsparse import sp_dot
from esn.optimize import lstsq_stable, imed_lstsq_stable
from esn.utils import _fromfile


def esncell(map_ih, hidden_size, spectral_radius=1.5, density=0.1):
    """
    Create an ESN with input, and hidden weights represented as a tuple:

        esn = (Wih, Whh, bh)

    The hidden matrix (the reservoir) is a sparse matrix in turn represented
    as a tuple of values, row/column indices, and its dense shape:
        Whh = (((values, rows, cols), shape)
    Arguments:
        map_ih: An `esn.input_map.InputMap`
        hidden_size: ESN hidden size
        spectral_radius: spectral radius of Whh
        density: density of Whh
    Returns:
        (Wih, Whh, bh)
    """
    Whh = sparse_esn_reservoir(hidden_size, spectral_radius, density, False)
    Whh = Whh.tocoo()
    bh  = np.random.uniform(-1, 1, (hidden_size,))
    model = (map_ih,
             ((jax.device_put(Whh.data),
              jax.device_put(Whh.row),
              jax.device_put(Whh.col)),
             Whh.shape),
             jax.device_put(bh))
    return model


def generate_states(esncell, xs, h0):
    """
    Apply and ESN defined by esncell (as in created from `sparse_esncell`) to
    each input in xs with the initial state h0. Each new input uses the updated
    state from the previous step.
    Arguments:
        esncell: An ESN tuple (Wih, Whh, bh)
        xs: Array of inputs. Time in first dimension.
        h0: Initial hidden state
    Returns:
        (h,hs) where
        h: Final hidden state
        hs: All hidden states
    """
    (map_ih, (Whh, shape), bh) = esncell
    def _step(h, x):
        h = jnp.tanh(sp_dot(Whh, h, shape[0]) + map_ih(x) + bh)
        return (h, h)
    (h, hs) = lax.scan(_step, h0, xs)
    return (h, hs)


def train(esncell, states, labels):
    """Compute the output matrix via least squares. and add it to the esncell
    tuple to create a model tuple.

    Params:
        esncell: ESN tuple (mapih, Whh, bh)
        states: state matrix as generated by 'augmented_state_matrix'
        labels: training labels (time, height, width)
    Returns:
        (mapih, Whh, bh, Who)
    """
    Who = lstsq_stable(states, labels)
    return esncell + (Who,)


def train_imed(esncell, states, inputs, labels):
    """Compute the output matrix via least squares in IMED space and add it
    to the esncell tuple to create a model tuple.

    Params:
        esncell: ESN tuple (mapih, Whh, bh)
        states: state matrix as generated by 'augmented_state_matrix'
        inputs: training inputs (time, height, width)
        labels: training labels (time, height, width)
    Returns:
        (mapih, Whh, bh, Who)
    """
    Who = imed_lstsq_stable(states, inputs, labels)
    return esncell + (Who,)


#@jax.jit
def predict(model, y0, h0, Npred):
    """
    Given a trained model = (Wih,Whh,bh,Who), a start internal state h0, and input
    y0 predict in free-running mode for Npred steps into the future, with
    output feeding back y_n as next input:

      h_{n+1} = \tanh(Whh h_n + Wih y_n + bh)
      y_{n+1} = Who h_{n+1}
    """
    if y0.ndim == 1:
        aug_len = y0.shape[0] + 1
    elif y0.ndim == 2:
        aug_len = y0.shape[0] * y0.shape[1] + 1
    else:
        raise ValueError("'y0' must either be a vector or a matrix.")

    (map_ih,(Whh,shape),bh,Who) = model
    def _step(input, xs):
        (y,h_augmented) = input
        h = h_augmented[aug_len:]
        h = jnp.tanh(sp_dot(Whh, h, shape[0]) + map_ih(y) + bh)
        h = jnp.hstack([[1.], y.reshape(-1), h])
        y = Who.dot(h).reshape(y.shape)
        return ((y,h), (y,h))

    xs = jnp.arange(Npred)  # necessary for lax.scan
    ((y,h), (ys,hs)) = lax.scan(_step, (y0,h0), xs)
    return ((y,h), (ys,hs))


def warmup_predict(model, imgs, Npred):
    """
    Given a trained ESN and a number input images 'imgs', predicts 'Npred'
    frames after the last frame of 'imgs'. The input images are used to
    create the inital state 'h0' for the prediction (warmup).
    """
    H = augmented_state_matrix(model[:-1], imgs, 0)
    h0 = H[-2]
    y0 = imgs[-1]
    return predict(model, y0, h0, Npred)


def hidden_size(esn):
    (_,shape) = esn[1]
    return shape[0]


def augmented_state_matrix(esncell, inputs, Ntrans):
    Ntrain = inputs.shape[0]

    h0 = jnp.zeros(hidden_size(esncell))

    (_,H) = generate_states(esncell, inputs, h0)
    H = jnp.vstack(H)

    H0 = H[Ntrans:]
    I0 = inputs[Ntrans:].reshape(Ntrain-Ntrans,-1)
    ones = jnp.ones((Ntrain-Ntrans,1))
    return jnp.concatenate([ones,I0,H0], axis=1)


def sparse_esn_reservoir(size, spectral_radius, density, symmetric):
    """Creates a CSR representation of a sparse ESN reservoir.
    Params:
        size: int, size of the square reservoir matrix
        spectral_radius: float, largest eigenvalue of the reservoir matrix
        density: float, 0.1 corresponds to approx every tenth element
            being non-zero
        symmetric: specifies if matrix.T == matrix
    Returns:
        matrix: a square scipy.sparse.csr_matrix
    """
    rvs = stats.uniform(loc=-1., scale=2.).rvs
    matrix = sparse.random(size, size, density=density, data_rvs=rvs)
    matrix = matrix.tocsr()
    if symmetric:
        matrix = sparse.triu(matrix)
        tril = sparse.tril(matrix.transpose(), k=-1)
        matrix = matrix + tril
        # calc eigenvalues with scipy's lanczos implementation:
        eig, _ = sparse.linalg.eigsh(matrix, k=2, tol=1e-4)
    else:
        eig, _ = sparse.linalg.eigs(matrix, k=2, tol=1e-4)

    rho = np.abs(eig).max()
    matrix = matrix.multiply(1. / rho)
    matrix = matrix.multiply(spectral_radius)
    return matrix


    map_ih = InputMap(input_map_specs)
    Whh = sparse_esn_reservoir(hidden_size, spectral_radius, density, False)
    Whh = Whh.tocoo()
    bh  = np.random.uniform(-1, 1, (hidden_size,))
    model = (map_ih,
             ((jax.device_put(Whh.data),
              jax.device_put(Whh.row),
              jax.device_put(Whh.col)),
             Whh.shape),
             jax.device_put(bh))
    return model


def device_put(model):
    (mapih, (Whh,shape), bh, Who) = model
    mapih.device_put()
    Whh = jax.device_put(Whh)
    bh  = jax.device_put(bh)
    Who = jax.device_put(Who)
    return (mapih, (Whh,shape), bh, Who)


def load_model(filename):
    with open(filename, "rb") as fi:
        m = joblib.load(fi)
    return device_put(m)
